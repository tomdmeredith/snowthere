"""Schemas for the Quality Audit Agent.

Defines the configuration, objectives, plans, and observations
used by QualityAuditAgent in its think→act→observe loops.
"""

from dataclasses import dataclass, field
from datetime import datetime
from typing import Any, Literal


@dataclass
class QuickScanConfig:
    """Configuration for quick scan mode (daily, database-only)."""

    staleness_threshold_days: int = 30
    confidence_threshold: float = 0.7
    status_filter: str = "published"
    max_resorts: int = 1000  # Scan all published by default


@dataclass
class DeepAuditConfig:
    """Configuration for deep audit mode (weekly, LLM-assisted)."""

    sample_size: int = 10
    staleness_threshold_days: int = 30
    confidence_threshold: float = 0.7
    check_price_drift: bool = True
    check_voice_consistency: bool = True
    check_external_links: bool = False  # Can be slow
    prioritize_countries: list[str] = field(default_factory=list)
    max_cost: float = 5.0  # Budget cap for this audit


@dataclass
class TriggeredAuditConfig:
    """Configuration for triggered mode (on-demand, single resort)."""

    resort_id: str = ""
    full_audit: bool = True
    include_recommendations: bool = True


@dataclass
class AuditObjective:
    """Objective passed to QualityAuditAgent.run()."""

    mode: Literal["quick_scan", "deep_audit", "triggered"]
    config: QuickScanConfig | DeepAuditConfig | TriggeredAuditConfig
    triggered_by: str = "cron"  # cron, manual, user_feedback, low_traffic
    context: dict[str, Any] = field(default_factory=dict)

    @classmethod
    def quick_scan(cls, **config_kwargs) -> "AuditObjective":
        """Create a quick scan objective."""
        return cls(
            mode="quick_scan",
            config=QuickScanConfig(**config_kwargs),
            triggered_by="cron",
        )

    @classmethod
    def deep_audit(cls, sample_size: int = 10, **config_kwargs) -> "AuditObjective":
        """Create a deep audit objective."""
        return cls(
            mode="deep_audit",
            config=DeepAuditConfig(sample_size=sample_size, **config_kwargs),
            triggered_by="cron",
        )

    @classmethod
    def triggered(cls, resort_id: str, triggered_by: str = "manual") -> "AuditObjective":
        """Create a triggered audit objective for a single resort."""
        return cls(
            mode="triggered",
            config=TriggeredAuditConfig(resort_id=resort_id),
            triggered_by=triggered_by,
        )


@dataclass
class AuditPlanStep:
    """A single step in the audit plan."""

    step_id: int
    action: str  # check_staleness, check_confidence, llm_assess_quality, etc.
    targets: list[str]  # Resort IDs or "all"
    estimated_cost: float = 0.0
    estimated_duration_seconds: float = 0.0
    depends_on: list[int] = field(default_factory=list)  # Step IDs this depends on


@dataclass
class QualityAuditPlan:
    """Plan generated by QualityAuditAgent._think()."""

    mode: str
    steps: list[AuditPlanStep]
    reasoning: str
    estimated_total_cost: float = 0.0
    estimated_total_duration_seconds: float = 0.0
    resort_sample: list[str] = field(default_factory=list)  # IDs of resorts to audit
    checks_to_run: list[str] = field(default_factory=list)

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary for storage."""
        return {
            "mode": self.mode,
            "steps": [
                {
                    "step_id": s.step_id,
                    "action": s.action,
                    "targets": s.targets,
                    "estimated_cost": s.estimated_cost,
                    "depends_on": s.depends_on,
                }
                for s in self.steps
            ],
            "reasoning": self.reasoning,
            "estimated_total_cost": self.estimated_total_cost,
            "resort_sample": self.resort_sample,
            "checks_to_run": self.checks_to_run,
        }


@dataclass
class QualityObservation:
    """Observation generated by QualityAuditAgent._observe()."""

    success: bool
    issues_found: int
    issues_fixed: int
    issues_queued: int
    issues_escalated: int

    # Patterns learned from this audit
    patterns_discovered: list[str] = field(default_factory=list)

    # Lessons for future audits
    lessons: list[str] = field(default_factory=list)

    # Recommendations for improving content quality
    recommendations: list[str] = field(default_factory=list)

    # Meta-observations about the audit process itself
    process_notes: str = ""

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary for storage."""
        return {
            "success": self.success,
            "issues_found": self.issues_found,
            "issues_fixed": self.issues_fixed,
            "issues_queued": self.issues_queued,
            "issues_escalated": self.issues_escalated,
            "patterns_discovered": self.patterns_discovered,
            "lessons": self.lessons,
            "recommendations": self.recommendations,
            "process_notes": self.process_notes,
        }


# =============================================================================
# Severity Rules (used by agent to classify issues)
# =============================================================================


SEVERITY_RULES = {
    "critical": [
        "published with confidence < 0.5",
        "missing required section while published",
        "price drift > 50%",
        "no content record exists",
    ],
    "high": [
        "stale > 60 days",
        "price drift > 20%",
        "published with confidence < 0.7",
        "missing required section",
    ],
    "medium": [
        "stale > 30 days",
        "missing optional section",
        "confidence < 0.8",
    ],
    "low": [
        "voice inconsistency",
        "minor formatting issues",
        "missing optional fields",
    ],
}


# =============================================================================
# Check Configuration (what checks to run in each mode)
# =============================================================================


QUICK_SCAN_CHECKS = [
    "staleness",
    "low_confidence",
    "completeness",
]

DEEP_AUDIT_CHECKS = [
    "staleness",
    "low_confidence",
    "completeness",
    "price_drift",
    "voice_consistency",
]

TRIGGERED_AUDIT_CHECKS = [
    "staleness",
    "low_confidence",
    "completeness",
    "price_drift",
    "voice_consistency",
    "external_links",
    "data_consistency",
]
